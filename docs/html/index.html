<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ModusToolbox Power Conversion Middleware</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ModusToolbox Power Conversion Middleware</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ModusToolbox Power Conversion Middleware </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >The Power Conversion Middleware provides a solid solution to design power convertors easily.</p>
<h1><a class="anchor" id="section_pwrconv_features"></a>
Features</h1>
<ul>
<li>Configurable by the Power Conversion Configurator (PCC)</li>
<li>Synchronous Buck Converter topology support</li>
<li>Voltage-control (VCM) and Peak-current control (PCCM) modes support</li>
<li>Multi-instance support (up to 4 instances)</li>
<li>Multi-phase support (up to 4 phases)</li>
<li>Auto-generated control loop and Custom (user-defined) control loop modes support</li>
<li>Built-in 2p2z and 3p3z regulators</li>
<li>Basic ramp generator</li>
<li>Pre- and Post-processing user callbacks in the Auto-generated control loop mode</li>
<li>Separately scheduled ADC sequencer group for the slow parameters</li>
</ul>
<h1><a class="anchor" id="section_pwrconv_glossary"></a>
Glossary</h1>
<ul>
<li>PCC - Power Conversion Configurator</li>
<li>VCM - voltage control mode, firmware regulator directly controls the PWM pulse width value.</li>
<li>PCCM - peak-current control mode, firmware regulator (outer control loop) control of the DAC slope value, a reference for the comparator (the inner HW control loop)</li>
</ul>
<h1><a class="anchor" id="section_pwrconv_general"></a>
General Description</h1>
<p >The Power Conversion Middleware consists of the device-agnostic top-level API source code, the power conversion library source code, and the solution personality. The solution personality:</p><ul>
<li>provides the integration with the Power Conversion Configurator and Device Configurator.</li>
<li>calculates the regulator coefficients</li>
<li>generates the power conversion regulator configuration code and device-specific HW configuration code</li>
<li>generates the control loop ISR <div class="image">
<img src="solution.png" alt=""/>
</div>
</li>
</ul>
<h1><a class="anchor" id="section_pwrconv_quickstart"></a>
Quick Start</h1>
<p >Assume the power converter instance is named in the ModusToolbox&trade; Device Configurator as 'myPwrConv': </p><div class="image">
<img src="myPwrConv.png" alt=""/>
</div>
<p >Then, the simplest way to use myPwrConv is to use generated myPwrConv API: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cycfg.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> scheduler_callback(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="group__group__pwrconv__gen__func.html#ga1632e5f9923723d83aaa16d353474b7b">myPwrConv_ramp</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    init_cycfg_all(); <span class="comment">/* Initialize everything configured by the Device Configurator */</span></div>
<div class="line"> </div>
<div class="line">    __enable_irq();</div>
<div class="line"> </div>
<div class="line">    (void) Cy_SysTick_SetCallback(0UL, scheduler_callback);</div>
<div class="line">    Cy_SysTick_Enable(); <span class="comment">/* A simple scheduled event timer */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__group__pwrconv__gen__func.html#gaf0b201d5379af4623a042f7ca400df79">myPwrConv_enable</a>(); <span class="comment">/* Set target and enable HW */</span></div>
<div class="line">    <a class="code hl_function" href="group__group__pwrconv__gen__func.html#gaf998227693c5f3b2ca15d77957e4dc7a">myPwrConv_start</a>(); <span class="comment">/* Start HW */</span></div>
<div class="line">    <span class="keywordflow">while</span> (0UL != <a class="code hl_function" href="group__group__pwrconv__gen__func.html#ga6b9e5dd4042226ab22e6ae4c8f9447f8">myPwrConv_get_state</a>(<a class="code hl_define" href="group__group__pwrconv__states.html#ga3e4573e23a208bc6f97e4aef6d9916fd">MTB_PWRCONV_STATE_RAMP</a>)); <span class="comment">/* Wait while it is ramping to the target */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Work with original target (configured in PCC) */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__group__pwrconv__gen__func.html#ga763cac10a7f11e8d8fe200b1208982d9">myPwrConv_set_target</a>(4500); <span class="comment">/* Change the target to e.g. 4.5V */</span></div>
<div class="line">    <span class="keywordflow">while</span> (0UL != <a class="code hl_function" href="group__group__pwrconv__gen__func.html#ga6b9e5dd4042226ab22e6ae4c8f9447f8">myPwrConv_get_state</a>(<a class="code hl_define" href="group__group__pwrconv__states.html#ga3e4573e23a208bc6f97e4aef6d9916fd">MTB_PWRCONV_STATE_RAMP</a>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Now ramping is ended and the converter works with new target */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__pwrconv__gen__func_html_ga1632e5f9923723d83aaa16d353474b7b"><div class="ttname"><a href="group__group__pwrconv__gen__func.html#ga1632e5f9923723d83aaa16d353474b7b">myPwrConv_ramp</a></div><div class="ttdeci">void myPwrConv_ramp(void)</div><div class="ttdoc">Drives the Ramp Generator.</div></div>
<div class="ttc" id="agroup__group__pwrconv__gen__func_html_ga6b9e5dd4042226ab22e6ae4c8f9447f8"><div class="ttname"><a href="group__group__pwrconv__gen__func.html#ga6b9e5dd4042226ab22e6ae4c8f9447f8">myPwrConv_get_state</a></div><div class="ttdeci">cy_rslt_t myPwrConv_get_state(uint32_t mask)</div><div class="ttdoc">Returns the Power Converter instance current state.</div></div>
<div class="ttc" id="agroup__group__pwrconv__gen__func_html_ga763cac10a7f11e8d8fe200b1208982d9"><div class="ttname"><a href="group__group__pwrconv__gen__func.html#ga763cac10a7f11e8d8fe200b1208982d9">myPwrConv_set_target</a></div><div class="ttdeci">cy_rslt_t myPwrConv_set_target(uint32_t targ)</div><div class="ttdoc">Applies a new target for the Ramp Generator.</div></div>
<div class="ttc" id="agroup__group__pwrconv__gen__func_html_gaf0b201d5379af4623a042f7ca400df79"><div class="ttname"><a href="group__group__pwrconv__gen__func.html#gaf0b201d5379af4623a042f7ca400df79">myPwrConv_enable</a></div><div class="ttdeci">cy_rslt_t myPwrConv_enable(void)</div><div class="ttdoc">Enables the Power Conversion Control System.</div></div>
<div class="ttc" id="agroup__group__pwrconv__gen__func_html_gaf998227693c5f3b2ca15d77957e4dc7a"><div class="ttname"><a href="group__group__pwrconv__gen__func.html#gaf998227693c5f3b2ca15d77957e4dc7a">myPwrConv_start</a></div><div class="ttdeci">cy_rslt_t myPwrConv_start(void)</div><div class="ttdoc">Starts the Power Conversion instance.</div></div>
<div class="ttc" id="agroup__group__pwrconv__states_html_ga3e4573e23a208bc6f97e4aef6d9916fd"><div class="ttname"><a href="group__group__pwrconv__states.html#ga3e4573e23a208bc6f97e4aef6d9916fd">MTB_PWRCONV_STATE_RAMP</a></div><div class="ttdeci">#define MTB_PWRCONV_STATE_RAMP</div><div class="ttdoc">The ramping flag, indicates that the converter currently is changing the reference value smoothly to ...</div><div class="ttdef"><b>Definition:</b> mtb_pwrconv.h:233</div></div>
</div><!-- fragment --><h1><a class="anchor" id="section_pwrconv_infineon"></a>
Infineon Control Loop</h1>
<p >The whole control loop including the regulator is generated by the personality. The control loop consists of:</p><ul>
<li>retrieving the ADC feedback value from the ADC register into <a class="el" href="group__group__pwrconv__data__structures.html#adaf1be7c52e2a5910630fa23bf0ba51e">mtb_stc_pwrconv_ctx_t::res</a></li>
<li>the error calculation: <a class="el" href="group__group__pwrconv__data__structures.html#affb6943f209da62c63d3ae5636fcf64e">mtb_stc_pwrconv_ctx_t::err</a> = <a class="el" href="group__group__pwrconv__data__structures.html#a3ea31a04cf73e8272e93644aaee397b7">mtb_stc_pwrconv_ctx_t::ref</a> - <a class="el" href="group__group__pwrconv__data__structures.html#adaf1be7c52e2a5910630fa23bf0ba51e">mtb_stc_pwrconv_ctx_t::res</a></li>
<li>optionally, the pre-process user callback execution, which is a way to apply any user-specific pre-filtering to the <a class="el" href="group__group__pwrconv__data__structures.html#affb6943f209da62c63d3ae5636fcf64e">mtb_stc_pwrconv_ctx_t::err</a> value, or perform some protection actions (e.g. check ADC channel values for ranges and stop the conversion in case of any parameter violation)</li>
<li>performing the regulation itself</li>
<li>optionally the post-process user callback execution, which is a way to apply any user-specific post-filtering to the modulator <a class="el" href="group__group__pwrconv__data__structures.html#aa57fa54aedf1a99aad04f7009b1d39f2">mtb_stc_pwrconv_ctx_t::mod</a> value</li>
<li>apply the modulator <a class="el" href="group__group__pwrconv__data__structures.html#aa57fa54aedf1a99aad04f7009b1d39f2">mtb_stc_pwrconv_ctx_t::mod</a> value to the modulator itself (update PWM duty cycle in VCM or DAC start/stop values in PCCM)</li>
</ul>
<h2><a class="anchor" id="subsection_pwrconv_pre_post_process"></a>
Infineon Control Loop Callbacks</h2>
<p >To use the pre- or/and post-process callbacks, the callback itself should be declared at the application level, the corresponding feature should be enabled in the PCC tool Controller tab: </p><div class="image">
<img src="preCb.png" alt=""/>
</div>
<p> and the callback name should be passed into the Device Configurator GUI: </p><div class="image">
<img src="callback.png" alt=""/>
</div>
<p> To make these callbacks faster, they can be declared as inline functions in header file - in this case the header file name should be also passed into the Device Configurator GUI, as shown above.</p>
<p >And then in the myHeader.h: </p><div class="fragment"><div class="line">__STATIC_INLINE <span class="keywordtype">void</span> myPwrConv_pre_process_callback(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> int32_t error = 0; <span class="comment">/* store the current error value */</span></div>
<div class="line">    error = error / 2 + myPwrConv.ctx-&gt;err / 2; <span class="comment">/* the simplest first-order error filtering */</span></div>
<div class="line">    myPwrConv.ctx-&gt;err = error; <span class="comment">/* feed the filtered error value into the regulator */</span></div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>For non-inline callbacks there is no need to update the 'Header file name' parameter - it can be left empty (by default).</dd></dl>
<h1><a class="anchor" id="section_pwrconv_custom"></a>
Custom Control Loop</h1>
<p >In the Custom Control Loop mode:</p><ul>
<li>there is no dedicated feedback ADC channel defined in the Control Loop ADC Group - all the channels are equally 'custom'. Therefore, the error <a class="el" href="group__group__pwrconv__data__structures.html#affb6943f209da62c63d3ae5636fcf64e">mtb_stc_pwrconv_ctx_t::err</a> is not being calculated in the Control Loop ISR (unlike in the Infineon Control Loop mode). It is the user's task to define the controlled value(s) and to perform the feedback processing and regulation.</li>
<li>the custom control loop callback is being called instead of the default (Infineon Control Loop mode) bult-in regulator with pre-/post-process callbacks.</li>
<li>the modulator update with the <a class="el" href="group__group__pwrconv__data__structures.html#aa57fa54aedf1a99aad04f7009b1d39f2">mtb_stc_pwrconv_ctx_t::mod</a> value works exactly like in the Infineon Control Loop mode.</li>
<li>the <a class="el" href="group__group__pwrconv__gen__func.html#ga763cac10a7f11e8d8fe200b1208982d9">myPwrConv_set_target</a> function is transparent - the reference value nominally equals to the target value, without any min/max limitations nor recalculations, because the target is not predefined by the solution itself - it should be defined by user at the application level. <div class="image">
<img src="custom.png" alt=""/>
</div>
 For example to use the inline custom callback, the callback name and the header file name should be entered into the Device Configurator: <div class="image">
<img src="custCb.png" alt=""/>
</div>
 And then in the myCustom.h: <div class="fragment"><div class="line">__STATIC_INLINE <span class="keywordtype">void</span> myPwrConv_custom_callback(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> float32_t modAvg = 0.0;</div>
<div class="line"> </div>
<div class="line">    myPwrConv_ctx.res = <a class="code hl_function" href="group__group__pwrconv__gen__func.html#gab780ffb30d45a7a411ffc2f1f48deb4d">myPwrConv_Vout_get_result</a>(); <span class="comment">/* Retrieving the feedback value */</span></div>
<div class="line"> </div>
<div class="line">    modAvg = 0.99 * modAvg + 0.01 * <a class="code hl_function" href="group__group__pwrconv__gen__func.html#gaef4f53d99ab1e1659ddb587e35d16823">myPwrConv_get_error</a>(); <span class="comment">/* The simplest first-order regulator */</span></div>
<div class="line"> </div>
<div class="line">    modAvg = (modAvg &lt; myPwrConv_SLOPE_START_MIN) ? myPwrConv_SLOPE_START_MIN : <span class="comment">/* Anti-windup limitation */</span></div>
<div class="line">             (modAvg &gt; myPwrConv_SLOPE_START_MAX) ? myPwrConv_SLOPE_START_MAX : modAvg;</div>
<div class="line"> </div>
<div class="line">    myPwrConv.ctx-&gt;mod = (int32_t)modAvg; <span class="comment">/* Update modulator */</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__pwrconv__gen__func_html_gab780ffb30d45a7a411ffc2f1f48deb4d"><div class="ttname"><a href="group__group__pwrconv__gen__func.html#gab780ffb30d45a7a411ffc2f1f48deb4d">myPwrConv_Vout_get_result</a></div><div class="ttdeci">__STATIC_FORCEINLINE uint32_t myPwrConv_Vout_get_result(void)</div><div class="ttdoc">Gets the ADC channel result in raw counts.</div></div>
<div class="ttc" id="agroup__group__pwrconv__gen__func_html_gaef4f53d99ab1e1659ddb587e35d16823"><div class="ttname"><a href="group__group__pwrconv__gen__func.html#gaef4f53d99ab1e1659ddb587e35d16823">myPwrConv_get_error</a></div><div class="ttdeci">__STATIC_FORCEINLINE int32_t myPwrConv_get_error(uint32_t result)</div><div class="ttdoc">Calculates the error value from the feedback and reference values.</div></div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="section_pwrconv_scheduled"></a>
Scheduled ADC Group</h1>
<p >To optimize the control loop timing, some ADC measurements can be performed not in the control loop ADC sequencer group, but in the separate scheduled ADC group (configurable in the PCC tool ADC tab): </p><div class="image">
<img src="schedCh.png" alt=""/>
</div>
<p> which is being periodically triggered by the <a class="el" href="group__group__pwrconv__gen__func.html#ga0311d2f32bdf39385c683d161af83aba">myPwrConv_scheduled_adc_trigger</a> function. When the scheduled ADC group measurement is done - it rises interrupt which calls the scheduled user callback, which name also should be passed into the Device Configurator GUI: </p><div class="image">
<img src="schedCb.png" alt=""/>
</div>
<p> And implemented in the application code: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> scheduler_callback(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="group__group__pwrconv__gen__func.html#ga1632e5f9923723d83aaa16d353474b7b">myPwrConv_ramp</a>();</div>
<div class="line">    <a class="code hl_function" href="group__group__pwrconv__gen__func.html#ga0311d2f32bdf39385c683d161af83aba">myPwrConv_scheduled_adc_trigger</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> myPwrConv_scheduled_adc_callback(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (myPwrConv_Temp_MAX &lt; myPwrConv_Temp_get_result())</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_function" href="group__group__pwrconv__gen__func.html#gac60fed58031098cb3a675e3d37f17816">myPwrConv_disable</a>(); <span class="comment">/* Emergency stop for overheat protection */</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__pwrconv__gen__func_html_ga0311d2f32bdf39385c683d161af83aba"><div class="ttname"><a href="group__group__pwrconv__gen__func.html#ga0311d2f32bdf39385c683d161af83aba">myPwrConv_scheduled_adc_trigger</a></div><div class="ttdeci">void myPwrConv_scheduled_adc_trigger(void)</div><div class="ttdoc">Triggers the scheduled ADC group.</div></div>
<div class="ttc" id="agroup__group__pwrconv__gen__func_html_gac60fed58031098cb3a675e3d37f17816"><div class="ttname"><a href="group__group__pwrconv__gen__func.html#gac60fed58031098cb3a675e3d37f17816">myPwrConv_disable</a></div><div class="ttdeci">cy_rslt_t myPwrConv_disable(void)</div><div class="ttdoc">Disables (stops) the Power Conversion Control System.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="section_pwrconv_modulator"></a>
Modulation modes</h1>
<h2><a class="anchor" id="subsection_pwrconv_vcm"></a>
VCM</h2>
<p >Voltage control modulation mode - the simple PWM, where the pulse width is directly controlled by the 3P3Z regulator (in the <a class="el" href="index.html#section_pwrconv_infineon">Infineon Control Loop</a> mode). Supports both high resolution and regular resolution TCPWM modes (configurable in the PCC tool) </p><div class="image">
<img src="hires.png" alt=""/>
</div>
<h2><a class="anchor" id="subsection_pwrconv_pccm"></a>
PCCM</h2>
<p >Peak-Current control mode is the advanced modulation method which consists of two loops:</p><ul>
<li>the inner HW inductor current control loop</li>
<li>the outer FW 2P2Z regulator (in Infineon control loop mode) which controls the PCCM's comparator reference (DAC slope): <div class="image">
<img src="PCCM.png" alt=""/>
</div>
</li>
</ul>
<h1><a class="anchor" id="section_pwrconv_ramp"></a>
Ramp Generator</h1>
<p >The PwrConv middleware provides a simple ramp generator - the <a class="el" href="group__group__pwrconv__functions.html#gaa16b58b55022a5d6b82c45de9e306d3b">mtb_pwrconv_ramp</a> function which should be called by a periodical event (e.g. some timer ISR/callback, the timing is important to be determined and stable): </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cycfg.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> scheduler_callback(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="group__group__pwrconv__gen__func.html#ga1632e5f9923723d83aaa16d353474b7b">myPwrConv_ramp</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    init_cycfg_all(); <span class="comment">/* Initialize everything configured by the Device Configurator */</span></div>
<div class="line"> </div>
<div class="line">    __enable_irq();</div>
<div class="line"> </div>
<div class="line">    (void) Cy_SysTick_SetCallback(0UL, scheduler_callback);</div>
<div class="line">    Cy_SysTick_Enable(); <span class="comment">/* A simple scheduled event timer */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__group__pwrconv__gen__func.html#gaf0b201d5379af4623a042f7ca400df79">myPwrConv_enable</a>(); <span class="comment">/* Set target and enable HW */</span></div>
<div class="line">    <a class="code hl_function" href="group__group__pwrconv__gen__func.html#gaf998227693c5f3b2ca15d77957e4dc7a">myPwrConv_start</a>(); <span class="comment">/* Start HW */</span></div>
<div class="line">    <span class="keywordflow">while</span> (0UL != <a class="code hl_function" href="group__group__pwrconv__gen__func.html#ga6b9e5dd4042226ab22e6ae4c8f9447f8">myPwrConv_get_state</a>(<a class="code hl_define" href="group__group__pwrconv__states.html#ga3e4573e23a208bc6f97e4aef6d9916fd">MTB_PWRCONV_STATE_RAMP</a>)); <span class="comment">/* Wait while it is ramping to the target */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Work with original target (configured in PCC) */</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__group__pwrconv__gen__func.html#ga763cac10a7f11e8d8fe200b1208982d9">myPwrConv_set_target</a>(4500); <span class="comment">/* Change the target to e.g. 4.5V */</span></div>
<div class="line">    <span class="keywordflow">while</span> (0UL != <a class="code hl_function" href="group__group__pwrconv__gen__func.html#ga6b9e5dd4042226ab22e6ae4c8f9447f8">myPwrConv_get_state</a>(<a class="code hl_define" href="group__group__pwrconv__states.html#ga3e4573e23a208bc6f97e4aef6d9916fd">MTB_PWRCONV_STATE_RAMP</a>));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Now ramping is ended and the converter works with new target */</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p> The ramp generator updates the <a class="el" href="group__group__pwrconv__data__structures.html#a3ea31a04cf73e8272e93644aaee397b7">mtb_stc_pwrconv_ctx_t::ref</a> value so that it always moves towards the <a class="el" href="group__group__pwrconv__data__structures.html#af37af7652fb5f6cdbc53a06580bb5ce6">mtb_stc_pwrconv_ctx_t::targ</a> value with the steps defined by <a class="el" href="group__group__pwrconv__data__structures.html#a4792b9aeb45c1aab3b255fec8d5b5aa4">mtb_stc_pwrconv_t::rampStep</a> based on Ramp update period and Ramp slope parameters configurable in the PCC tool: </p><div class="image">
<img src="ramp.png" alt=""/>
</div>
<h1><a class="anchor" id="section_pwrconv_syncstart"></a>
Synchronous Start</h1>
<p >When there are multiple instances with the same switching frequencies, there might be a need to start them simultaneously with specified phase shift, to avoid the control loop execution overlapping. In this case the 'Initial phase' parameter could be used: </p><div class="image">
<img src="initPhase.png" alt=""/>
</div>
<p> in conjunction with a generated <a class="el" href="group__group__pwrconv__gen__func.html#ga80f16e2ca0c1766b8930e794cdccadd7" title="Starts all the Power Conversion instances in the project synchronously.">pwrconv_start()</a> function (common for all the instances) instead of regular instance-based [instance_name]_start() functions: </p><div class="fragment"><div class="line">    <span class="comment">/* separately start each instance */</span></div>
<div class="line">    <span class="comment">//firstBuck_start();</span></div>
<div class="line">    <span class="comment">//secondBuck_start();</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* multi-instance synchronous start */</span></div>
<div class="line">    <a class="code hl_function" href="group__group__pwrconv__gen__func.html#ga80f16e2ca0c1766b8930e794cdccadd7">pwrconv_start</a>();</div>
<div class="ttc" id="agroup__group__pwrconv__gen__func_html_ga80f16e2ca0c1766b8930e794cdccadd7"><div class="ttname"><a href="group__group__pwrconv__gen__func.html#ga80f16e2ca0c1766b8930e794cdccadd7">pwrconv_start</a></div><div class="ttdeci">cy_rslt_t pwrconv_start(void)</div><div class="ttdoc">Starts all the Power Conversion instances in the project synchronously.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="section_pwrconv_multiphase"></a>
Multi-Phase</h1>
<p >The multiple interleaved conversion phases allows to divide a total power between multiple parallel power circuits (switches, inductors) for better heat dissipation, reliability, and power density of the converter. Also, in terms of EMC the multi-phasing method lowers magnitude and spreads the spectrum of both the electromagnetic emissions and the voltage/current ripples on power lines. The PwrConv Buck topology allow up to 4 phases (in both VCM and PCCM modes) controlled by the same FW regulator (configurable in the PCC tool) </p><div class="image">
<img src="multiphase.png" alt=""/>
</div>
 </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>ModusToolbox Power Conversion Middleware</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
